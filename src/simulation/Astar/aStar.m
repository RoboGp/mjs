function Optimal_path = aStar(graph, vertex, start, target)

  o = -1;
  p = 1;
  
  [MAX_X MAX_Y] = size(graph);
  % Obtain Obstacle, Target and Robot Position. Initialize the MAP with input values
  % Obstacle=-1,Target = 0,Robot=1,Space=2
  j=0;

  %---------------------------------------------------
  % Lists used
  % Open List structure: is_on_list, xval,yval,parent_xval,parent_yval,hn,gn,fn
  % Closed List Structure: xval, yval
  %---------------------------------------------------
  OPEN=[];
  CLOSED=[];

  %Put all obstacles on the Closed list
  k=1;			
  for i=1:MAX_X
    for j=1:MAX_Y
      if(MAP(i,j) == o)
	CLOSED(k,1)=i; 
	CLOSED(k,2)=j; 
	k=k+1;
      end
    end
  end
  CLOSED_COUNT=size(CLOSED,1);

  %set the starting node as the first node
  xNode = vertex(start, 1);
  yNode = vertex(start, 2);
  xt = vertex(target, 1);
  yt = vertex(target, 2);
  OPEN_COUNT = 1;
  path_cost = 0;
  goal_distance = distance(xNode, yNode, xt, yt);

  OPEN(OPEN_COUNT,:) = insert_open(xNode, yNode, xNode, yNode, path_cost, goal_distance, goal_distance);
  OPEN(OPEN_COUNT,1) = 0;

  CLOSED_COUNT = CLOSED_COUNT+1;
  CLOSED(CLOSED_COUNT,1) = xNode;
  CLOSED(CLOSED_COUNT,2) = yNode;
  NoPath = 1;


  %---------------------------------------------------
  % START ALGORITHM
  %---------------------------------------------------
  while((xNode ~= xt || yNode ~= yt)) && NoPath == 1)

  exp_array=expand_array(xNode, yNode, path_cost, xt, yt, CLOSED, MAX_X,MAX_Y);
  exp_count=size(exp_array,1)

  %UPDATE LIST OPEN WITH THE SUCCESSOR NODES
  %EXPANDED ARRAY FORMAT
  %--------------------------------
  %|X val |Y val ||h(n) |g(n)|f(n)|
  %--------------------------------

  for i=1:exp_count
      flag=0;

      for j=1:OPEN_COUNT
	if(exp_array(i,1) == OPEN(j,2) && exp_array(i,2) == OPEN(j,3) )
	  OPEN(j,8)=min(OPEN(j,8),exp_array(i,5)); %#ok<*SAGROW>
	  if OPEN(j,8)== exp_array(i,5)
						  %UPDATE PARENTS,gn,hn
	      OPEN(j,4)=xNode;
	      OPEN(j,5)=yNode;
	      OPEN(j,6)=exp_array(i,3);
	      OPEN(j,7)=exp_array(i,4);
	  end;					%End of minimum fn check
	  flag=1;
	end;					%End of node check
      end;					%End of j for
      
      if flag == 0
	  OPEN_COUNT = OPEN_COUNT+1;
	  OPEN(OPEN_COUNT,:)=insert_open(exp_array(i,1),exp_array(i,2),xNode,yNode,exp_array(i,3),exp_array(i,4),exp_array(i,5));
      end;%End of insert new element into the OPEN list
  end;%End of i for

  %---------------------------------------------------
  % WE're aiming towards the end of the while loop now
  %---------------------------------------------------

  %Find out the node with the smallest fn 
    index_min_node = min_fn(OPEN,OPEN_COUNT,xt,yt);
    if (index_min_node ~= -1)    
    %Set xNode and yNode to the node with minimum fn
    xNode=OPEN(index_min_node,2);
    yNode=OPEN(index_min_node,3);
    path_cost=OPEN(index_min_node,6);%Update the cost of reaching the parent node
    %Move the Node to list CLOSED
    CLOSED_COUNT=CLOSED_COUNT+1;
    CLOSED(CLOSED_COUNT,1)=xNode;
    CLOSED(CLOSED_COUNT,2)=yNode;
    OPEN(index_min_node,1)=0;
    else
				  %No path exists to the Target!!
	NoPath=0;			%Exits the loop!
    end;				%End of index_min_node check
  end;				%End of While Loop


  %Once algorithm has run The optimal path is generated by starting of at the
  %last node(if it is the target node) and then identifying its parent node
  %until it reaches the start node.This is the optimal path

  i=size(CLOSED,1);
  Optimal_path=[];
  xval=CLOSED(i,1);
  yval=CLOSED(i,2);
  i=1;
  Optimal_path(i,1)=xval;
  Optimal_path(i,2)=yval;
  i=i+1;

  if ( (xval == xt) && (yval == yt))
      inode=0;
    %Traverse OPEN and determine the parent nodes
    parent_x=OPEN(node_index(OPEN,xval,yval),4);%node_index returns the index of the node
    parent_y=OPEN(node_index(OPEN,xval,yval),5);
    
    while( parent_x ~= xStart || parent_y ~= yStart)
	    Optimal_path(i,1) = parent_x;
	    Optimal_path(i,2) = parent_y;
	    %Get the grandparents:-)
	    inode=node_index(OPEN,parent_x,parent_y);
	    parent_x=OPEN(inode,4);%node_index returns the index of the node
	    parent_y=OPEN(inode,5);
	    i=i+1;
      end;
  end

end





